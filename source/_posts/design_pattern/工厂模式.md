---
title: 设计模式之工厂模式
published: true
layout: post
date: 2025-11-25 11:28:07
permalink: /design_pattern/factory_pattern.html
categories: [设计模式]
---


## 一、简单工厂模式
### 概念
定义一个类，根据传入参数的不同，返回不同类的实例。



### 适用场景
1、创建对象逻辑不复杂：对象的创建过程比较简单，只是一些 `new`操作的组合

2、需要集中管理对象创建



### 常见例子
1、数据库连接工厂：传入“MySQL"、"PostgreSQL"等参数，返回对应的数据库连接对象

2、日志记录工厂：传入"File""Console"等参数，返回对应的日志记录器



### 类图


![image-20251125192904191](https://raw.githubusercontent.com/duwei0227/picbed/main/blogs/image-20251125192904191.png)

### 示例代码
#### 1、定义Product
```java
package cn.probiecoder;

public interface Chart {
    void display();
}

```



#### 2、定义具体的实现
```java
package cn.probiecoder;

public class LineChart implements Chart {
    @Override
    public void display() {
        System.out.println("Displaying Line Chart");
    }

}


package cn.probiecoder;

public class PieChart implements Chart {
    @Override
    public void display() {
        System.out.println("Displaying Pie Chart");
    }

}


package cn.probiecoder;

public class BarChart implements Chart {
    @Override
    public void display() {
        System.out.println("Displaying Bar Chart");
    }

}

```



#### 3、定义工厂类
```java
package cn.probiecoder.factory.simple;

import cn.probiecoder.BarChart;
import cn.probiecoder.Chart;
import cn.probiecoder.LineChart;
import cn.probiecoder.PieChart;

public class ChartFactory {
    public static Chart getChart(String type) {
        switch (type.toLowerCase()) {
            case "bar":
                return new BarChart();
            case "line":
                return new LineChart();
            case "pie":
                return new PieChart();
            default:
                throw new IllegalArgumentException("Unknown chart type: " + type);
        }
    }

}

```



#### 4、客户端调用
```java
package cn.probiecoder.factory.simple;

import cn.probiecoder.Chart;

public class Client {
    public static void main(String[] args) {
        Chart barChart = ChartFactory.getChart("BAR");
        barChart.display();

        Chart lineChart = ChartFactory.getChart("LINE");
        lineChart.display();
    }
}

```



## 二、工厂方法模式
### 概念
定义了一个用于创建对象的接口，但让之类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。

人话：工厂定义为接口，每一个具体的产品有一个对应的工厂子类用于创建对象实例。

### 适用场景
1、类的创建过程相对复杂，不是简单的`new`完成

2、产品的类型多样化，未来可能新增更多类型



与简单工厂模式的区别：

+ 简单工厂：把所有创建逻辑集中在一个工厂类中
+ 工厂方法：将创建逻辑分散到各个具体工厂子类中

### 类图
![image-20251125192934403](https://raw.githubusercontent.com/duwei0227/picbed/main/blogs/image-20251125192934403.png)

### 示例代码
#### 1、定义Product
```java
package cn.probiecoder;

public interface Chart {
    void display();
}

```



#### 2、定义具体的实现
```java
package cn.probiecoder;

public class LineChart implements Chart {
    @Override
    public void display() {
        System.out.println("Displaying Line Chart");
    }

}


package cn.probiecoder;

public class PieChart implements Chart {
    @Override
    public void display() {
        System.out.println("Displaying Pie Chart");
    }

}


package cn.probiecoder;

public class BarChart implements Chart {
    @Override
    public void display() {
        System.out.println("Displaying Bar Chart");
    }

}

```



#### 3、定义工厂类
```java
package cn.probiecoder.factory.method;

import cn.probiecoder.Chart;

public abstract class ChartFactory {

    public abstract Chart createChart();

    public void renderChart() {
        Chart chart = createChart();
        chart.display();
                System.out.println("图表渲染完成！");

    }
}



package cn.probiecoder.factory.method;

import cn.probiecoder.BarChart;
import cn.probiecoder.Chart;

// 具体工厂：柱状图工厂
public class BarChartFactory extends ChartFactory {
    @Override
    public Chart createChart() {
        System.out.println("创建柱状图工厂...");
        return new BarChart();
    }
}


package cn.probiecoder.factory.method;

import cn.probiecoder.Chart;
import cn.probiecoder.LineChart;

// 具体工厂：折线图工厂
public class LineChartFactory extends ChartFactory {
    @Override
    public Chart createChart() {
        // 可以在这里进行复杂的初始化操作
        System.out.println("创建折线图工厂...");
        return new LineChart();
    }
}


package cn.probiecoder.factory.method;

import cn.probiecoder.Chart;
import cn.probiecoder.PieChart;

// 具体工厂：饼图工厂
public class PieChartFactory extends ChartFactory {
    @Override
    public Chart createChart() {
        System.out.println("创建饼图工厂...");
        return new PieChart();
    }
}
```

#### 4、客户端调用
```java
package cn.probiecoder.factory.method;

import cn.probiecoder.Chart;

// 客户端
public class Client {
    public static void main(String[] args) {
        // 客户端选择使用哪种工厂
        ChartFactory factory;
        
        // 根据配置、用户输入等条件选择具体工厂
        String chartType = "line"; // 可以从配置文件读取
        
        switch (chartType) {
            case "line":
                factory = new LineChartFactory();
                break;
            case "pie":
                factory = new PieChartFactory();
                break;
            case "bar":
                factory = new BarChartFactory();
                break;
            default:
                throw new IllegalArgumentException("不支持的图表类型");
        }
        
        // 使用工厂创建并渲染图表
        factory.renderChart();
        // 输出：
        // 创建折线图工厂...
        // 显示折线图！
        // 图表渲染完成！
        
        // 也可以直接使用工厂方法
        Chart chart = factory.createChart();
        chart.display();
    }
}
```



#### 5、工厂方法结合简单工厂方式
工厂方法模式具体实例化那个工厂类的代码逻辑写在客户端类时,增加了客户端类的复杂性,且如果存在多个地方都需要创建对象时,修改点也增加,可以结合简单工厂模式,将参数化选择过程集中放在一个前置的简单工厂类中



+ 用工厂方法模式来组织产品创建的架构，保证扩展性
+ 用简单工厂模式来集中管理工厂对象的创建，简化客户端使用



前置简单工厂类:

```java
package cn.probiecoder.factory.method;

public class ChartFactoryCreator {
     // 静态方法创建具体工厂
    public static ChartFactory createFactory(String chartType) {
        switch (chartType.toLowerCase()) {
            case "line":
                return new LineChartFactory();
            case "pie":
                return new PieChartFactory();
            case "bar":
                return new BarChartFactory();
            default:
                throw new IllegalArgumentException("不支持的图表类型: " + chartType);
        }
    }
}

```



客户端类:

```java
package cn.probiecoder.factory.method;

import cn.probiecoder.Chart;

// 客户端
public class Client {
    public static void main(String[] args) {
        // 方式1：直接指定类型
        ChartFactory factory1 = ChartFactoryCreator.createFactory("line");
        factory1.renderChart();
        
        
        // 方式2：直接创建产品
        Chart chart = ChartFactoryCreator.createFactory("pie").createChart();
        chart.display();
    }
}
```

## 三、抽象工厂模式
### 概念
抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。

抽象工厂模式是工厂方法模式的扩展，它关注的是产品族的创建，而不仅仅是单个产品。一个产品族就是一系列相关的产品，它们通常一起使用，具有兼容性



工厂类需要支持创建产品族下的所有产品。



人话理解：一个产品或一个系统，由很多不同的子类产品组成，形成一个完成的系统，然后这个产品或系统在不同的平台（操作系统平台：`Linux Windows Mac Iphone`）有不同的实现或者不同的逻辑，也就是所抽象工厂模式在跨平台系统开发上会用到



举个例子：在使用Jetbrains KMP 进行跨平台开发的时候，业务逻辑层、样式的位置等可以共用，然而对于按钮、输入框等 `UI`组件，`Android`想要使用 `Google Compose`进行编写而 `IOS`端想要使用`SwiftUI`进行编写，这个时候就可以采用抽象工厂模式

### 适用场景
需要创建一系列相关的产品对象，这些产品需要一起使用，并且它们之间有兼容性要求。



### 常见例子
+ GUI 组件库：不同操作系统（`Windows、Mac、Linux`）的按钮、文本框、菜单等组件
+ 数据库访问层：不同数据库（`MySQL、Oracle、SQL Server`）的连接、命令、适配器等
+ 游戏开发：不同主题（科幻、中世纪、现代）的角色、武器、建筑等
+ 跨平台应用：不同平台的界面组件、文件操作、网络通信等

### 类图


![image-20251125193042213](https://raw.githubusercontent.com/duwei0227/picbed/main/blogs/image-20251125193042213.png)

### 示例代码
#### 1、定义Product
```java
package cn.probiecoder.factory.abs;

// 抽象产品：按钮
public interface Button {
    void render();
    void onClick();
}

package cn.probiecoder.factory.abs;

// 抽象产品：复选框
public interface Checkbox {
    void render();
    void check();
}


package cn.probiecoder.factory.abs;

// 抽象产品：文本框
public interface TextBox {
    void render();
    void setText(String text);
}

```

#### 2、定义具体的实现
```java
package cn.probiecoder.factory.abs;

public class AndroidButton implements Button {
    @Override
    public void render() {
        System.out.println("Rendering Android Button");
    }

    @Override
    public void onClick() {
        System.out.println("Android Button Clicked");
    }

}


package cn.probiecoder.factory.abs;

public class IphoneButton implements Button {
    @Override
    public void render() {
        System.out.println("Rendering iPhone Button");
    }

    @Override
    public void onClick() {
        System.out.println("iPhone Button Clicked");
    }

}

package cn.probiecoder.factory.abs;

public class AndroidCheckbox implements Checkbox {
    @Override
    public void render() {
        System.out.println("Rendering Android Checkbox");
    }

    @Override
    public void check() {
        System.out.println("Android Checkbox Checked");
    }

}


package cn.probiecoder.factory.abs;

public class IphoneCheckbox implements Checkbox {
    @Override
    public void render() {
        System.out.println("Rendering iPhone Checkbox");
    }

    @Override
    public void check() {
        System.out.println("iPhone Checkbox Checked");
    }

}


package cn.probiecoder.factory.abs;

public class AndroidTextBox implements TextBox {
    @Override
    public void render() {
        System.out.println("Rendering Android TextBox");
    }

    @Override
    public void setText(String text) {
        System.out.println("Setting text in Android TextBox: " + text);
    }

}


package cn.probiecoder.factory.abs;

public class IphoneTextBox implements TextBox {
    @Override
    public void render() {
        System.out.println("Rendering iPhone TextBox");
    }

    @Override
    public void setText(String text) {
        System.out.println("Setting text in iPhone TextBox: " + text);
    }

}
```

#### 3、定义工厂类
```java
package cn.probiecoder.factory.abs;

// 抽象GUI工厂
public interface GUIFactory {
    Button createButton();
    TextBox createTextBox();
    Checkbox createCheckbox();
}



package cn.probiecoder.factory.abs;

public class AndroidFactory implements GUIFactory {
    @Override
    public Button createButton() {
        return new AndroidButton();
    }

    @Override
    public TextBox createTextBox() {
        return new AndroidTextBox();
    }

    @Override
    public Checkbox createCheckbox() {
        return new AndroidCheckbox();
    }

}


package cn.probiecoder.factory.abs;

public class IphoneFactory implements GUIFactory {
    @Override
    public Button createButton() {
        return new IphoneButton();
    }

    @Override
    public TextBox createTextBox() {
        return new IphoneTextBox();
    }

    @Override
    public Checkbox createCheckbox() {
        return new IphoneCheckbox();
    }

}

```

#### 4、客户端调用
```java
package cn.probiecoder.factory.abs;

// 客户端
public class Client {
    private Button button;
    private TextBox textBox;
    private Checkbox checkbox;
    
    public Client(GUIFactory factory) {
        this.button = factory.createButton();
        this.textBox = factory.createTextBox();
        this.checkbox = factory.createCheckbox();
    }
    
    public void createUI() {
        System.out.println("创建用户界面...");
        button.render();
        textBox.render();
        checkbox.render();
        
        button.onClick();
        textBox.setText("Hello World");
        checkbox.check();
    }
    
    public static void main(String[] args) {
        // 根据配置或运行时环境选择工厂
        GUIFactory factory;
        
        String os = System.getProperty("os.name").toLowerCase();
        if (os.contains("android")) {
            factory = new AndroidFactory();
            System.out.println("使用Android风格界面");
        } else if (os.contains("iphone")) {
            factory = new IphoneFactory();
            System.out.println("使用Iphone风格界面");
        } else {
            // 默认使用Android风格
            factory = new AndroidFactory();
            System.out.println("使用默认Android风格界面");
        }
        
        // 创建客户端并构建界面
        Client client = new Client(factory);
        client.createUI();
    }
}

```



<font style="color:#F38F39;"></font>







